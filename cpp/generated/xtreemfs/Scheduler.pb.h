// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: xtreemfs/Scheduler.proto

#ifndef PROTOBUF_xtreemfs_2fScheduler_2eproto__INCLUDED
#define PROTOBUF_xtreemfs_2fScheduler_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "include/PBRPC.pb.h"
#include "include/Common.pb.h"
#include "xtreemfs/GlobalTypes.pb.h"
// @@protoc_insertion_point(includes)

namespace xtreemfs {
namespace pbrpc {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_xtreemfs_2fScheduler_2eproto();
void protobuf_AssignDesc_xtreemfs_2fScheduler_2eproto();
void protobuf_ShutdownFile_xtreemfs_2fScheduler_2eproto();

class osdIdentifier;
class volumeIdentifier;
class volumeSet;
class reservationSet;
class osdSet;
class reservation;
class freeResourcesResponse;

enum reservationType {
  STREAMING_RESERVATION = 1,
  RANDOM_IO_RESERVATION = 2,
  BEST_EFFORT_RESERVATION = 3,
  COLD_STORAGE_RESERVATION = 4
};
bool reservationType_IsValid(int value);
const reservationType reservationType_MIN = STREAMING_RESERVATION;
const reservationType reservationType_MAX = COLD_STORAGE_RESERVATION;
const int reservationType_ARRAYSIZE = reservationType_MAX + 1;

const ::google::protobuf::EnumDescriptor* reservationType_descriptor();
inline const ::std::string& reservationType_Name(reservationType value) {
  return ::google::protobuf::internal::NameOfEnum(
    reservationType_descriptor(), value);
}
inline bool reservationType_Parse(
    const ::std::string& name, reservationType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<reservationType>(
    reservationType_descriptor(), name, value);
}
// ===================================================================

class osdIdentifier : public ::google::protobuf::Message {
 public:
  osdIdentifier();
  virtual ~osdIdentifier();

  osdIdentifier(const osdIdentifier& from);

  inline osdIdentifier& operator=(const osdIdentifier& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const osdIdentifier& default_instance();

  void Swap(osdIdentifier* other);

  // implements Message ----------------------------------------------

  osdIdentifier* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const osdIdentifier& from);
  void MergeFrom(const osdIdentifier& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string uuid = 1;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 1;
  inline const ::std::string& uuid() const;
  inline void set_uuid(const ::std::string& value);
  inline void set_uuid(const char* value);
  inline void set_uuid(const char* value, size_t size);
  inline ::std::string* mutable_uuid();
  inline ::std::string* release_uuid();
  inline void set_allocated_uuid(::std::string* uuid);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.osdIdentifier)
 private:
  inline void set_has_uuid();
  inline void clear_has_uuid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uuid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fScheduler_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fScheduler_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fScheduler_2eproto();

  void InitAsDefaultInstance();
  static osdIdentifier* default_instance_;
};
// -------------------------------------------------------------------

class volumeIdentifier : public ::google::protobuf::Message {
 public:
  volumeIdentifier();
  virtual ~volumeIdentifier();

  volumeIdentifier(const volumeIdentifier& from);

  inline volumeIdentifier& operator=(const volumeIdentifier& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const volumeIdentifier& default_instance();

  void Swap(volumeIdentifier* other);

  // implements Message ----------------------------------------------

  volumeIdentifier* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const volumeIdentifier& from);
  void MergeFrom(const volumeIdentifier& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string uuid = 1;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 1;
  inline const ::std::string& uuid() const;
  inline void set_uuid(const ::std::string& value);
  inline void set_uuid(const char* value);
  inline void set_uuid(const char* value, size_t size);
  inline ::std::string* mutable_uuid();
  inline ::std::string* release_uuid();
  inline void set_allocated_uuid(::std::string* uuid);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.volumeIdentifier)
 private:
  inline void set_has_uuid();
  inline void clear_has_uuid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uuid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fScheduler_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fScheduler_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fScheduler_2eproto();

  void InitAsDefaultInstance();
  static volumeIdentifier* default_instance_;
};
// -------------------------------------------------------------------

class volumeSet : public ::google::protobuf::Message {
 public:
  volumeSet();
  virtual ~volumeSet();

  volumeSet(const volumeSet& from);

  inline volumeSet& operator=(const volumeSet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const volumeSet& default_instance();

  void Swap(volumeSet* other);

  // implements Message ----------------------------------------------

  volumeSet* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const volumeSet& from);
  void MergeFrom(const volumeSet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .xtreemfs.pbrpc.volumeIdentifier volumes = 1;
  inline int volumes_size() const;
  inline void clear_volumes();
  static const int kVolumesFieldNumber = 1;
  inline const ::xtreemfs::pbrpc::volumeIdentifier& volumes(int index) const;
  inline ::xtreemfs::pbrpc::volumeIdentifier* mutable_volumes(int index);
  inline ::xtreemfs::pbrpc::volumeIdentifier* add_volumes();
  inline const ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::volumeIdentifier >&
      volumes() const;
  inline ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::volumeIdentifier >*
      mutable_volumes();

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.volumeSet)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::volumeIdentifier > volumes_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fScheduler_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fScheduler_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fScheduler_2eproto();

  void InitAsDefaultInstance();
  static volumeSet* default_instance_;
};
// -------------------------------------------------------------------

class reservationSet : public ::google::protobuf::Message {
 public:
  reservationSet();
  virtual ~reservationSet();

  reservationSet(const reservationSet& from);

  inline reservationSet& operator=(const reservationSet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const reservationSet& default_instance();

  void Swap(reservationSet* other);

  // implements Message ----------------------------------------------

  reservationSet* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const reservationSet& from);
  void MergeFrom(const reservationSet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .xtreemfs.pbrpc.reservation reservations = 1;
  inline int reservations_size() const;
  inline void clear_reservations();
  static const int kReservationsFieldNumber = 1;
  inline const ::xtreemfs::pbrpc::reservation& reservations(int index) const;
  inline ::xtreemfs::pbrpc::reservation* mutable_reservations(int index);
  inline ::xtreemfs::pbrpc::reservation* add_reservations();
  inline const ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::reservation >&
      reservations() const;
  inline ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::reservation >*
      mutable_reservations();

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.reservationSet)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::reservation > reservations_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fScheduler_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fScheduler_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fScheduler_2eproto();

  void InitAsDefaultInstance();
  static reservationSet* default_instance_;
};
// -------------------------------------------------------------------

class osdSet : public ::google::protobuf::Message {
 public:
  osdSet();
  virtual ~osdSet();

  osdSet(const osdSet& from);

  inline osdSet& operator=(const osdSet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const osdSet& default_instance();

  void Swap(osdSet* other);

  // implements Message ----------------------------------------------

  osdSet* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const osdSet& from);
  void MergeFrom(const osdSet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .xtreemfs.pbrpc.osdIdentifier osd = 1;
  inline int osd_size() const;
  inline void clear_osd();
  static const int kOsdFieldNumber = 1;
  inline const ::xtreemfs::pbrpc::osdIdentifier& osd(int index) const;
  inline ::xtreemfs::pbrpc::osdIdentifier* mutable_osd(int index);
  inline ::xtreemfs::pbrpc::osdIdentifier* add_osd();
  inline const ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::osdIdentifier >&
      osd() const;
  inline ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::osdIdentifier >*
      mutable_osd();

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.osdSet)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::osdIdentifier > osd_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fScheduler_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fScheduler_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fScheduler_2eproto();

  void InitAsDefaultInstance();
  static osdSet* default_instance_;
};
// -------------------------------------------------------------------

class reservation : public ::google::protobuf::Message {
 public:
  reservation();
  virtual ~reservation();

  reservation(const reservation& from);

  inline reservation& operator=(const reservation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const reservation& default_instance();

  void Swap(reservation* other);

  // implements Message ----------------------------------------------

  reservation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const reservation& from);
  void MergeFrom(const reservation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .xtreemfs.pbrpc.volumeIdentifier volume = 1;
  inline bool has_volume() const;
  inline void clear_volume();
  static const int kVolumeFieldNumber = 1;
  inline const ::xtreemfs::pbrpc::volumeIdentifier& volume() const;
  inline ::xtreemfs::pbrpc::volumeIdentifier* mutable_volume();
  inline ::xtreemfs::pbrpc::volumeIdentifier* release_volume();
  inline void set_allocated_volume(::xtreemfs::pbrpc::volumeIdentifier* volume);

  // required .xtreemfs.pbrpc.reservationType type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::xtreemfs::pbrpc::reservationType type() const;
  inline void set_type(::xtreemfs::pbrpc::reservationType value);

  // required double capacity = 3;
  inline bool has_capacity() const;
  inline void clear_capacity();
  static const int kCapacityFieldNumber = 3;
  inline double capacity() const;
  inline void set_capacity(double value);

  // optional double streamingThroughput = 4;
  inline bool has_streamingthroughput() const;
  inline void clear_streamingthroughput();
  static const int kStreamingThroughputFieldNumber = 4;
  inline double streamingthroughput() const;
  inline void set_streamingthroughput(double value);

  // optional double randomThroughput = 5;
  inline bool has_randomthroughput() const;
  inline void clear_randomthroughput();
  static const int kRandomThroughputFieldNumber = 5;
  inline double randomthroughput() const;
  inline void set_randomthroughput(double value);

  // optional .xtreemfs.pbrpc.osdSet schedule = 6;
  inline bool has_schedule() const;
  inline void clear_schedule();
  static const int kScheduleFieldNumber = 6;
  inline const ::xtreemfs::pbrpc::osdSet& schedule() const;
  inline ::xtreemfs::pbrpc::osdSet* mutable_schedule();
  inline ::xtreemfs::pbrpc::osdSet* release_schedule();
  inline void set_allocated_schedule(::xtreemfs::pbrpc::osdSet* schedule);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.reservation)
 private:
  inline void set_has_volume();
  inline void clear_has_volume();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_capacity();
  inline void clear_has_capacity();
  inline void set_has_streamingthroughput();
  inline void clear_has_streamingthroughput();
  inline void set_has_randomthroughput();
  inline void clear_has_randomthroughput();
  inline void set_has_schedule();
  inline void clear_has_schedule();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::xtreemfs::pbrpc::volumeIdentifier* volume_;
  double capacity_;
  double streamingthroughput_;
  double randomthroughput_;
  ::xtreemfs::pbrpc::osdSet* schedule_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fScheduler_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fScheduler_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fScheduler_2eproto();

  void InitAsDefaultInstance();
  static reservation* default_instance_;
};
// -------------------------------------------------------------------

class freeResourcesResponse : public ::google::protobuf::Message {
 public:
  freeResourcesResponse();
  virtual ~freeResourcesResponse();

  freeResourcesResponse(const freeResourcesResponse& from);

  inline freeResourcesResponse& operator=(const freeResourcesResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const freeResourcesResponse& default_instance();

  void Swap(freeResourcesResponse* other);

  // implements Message ----------------------------------------------

  freeResourcesResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const freeResourcesResponse& from);
  void MergeFrom(const freeResourcesResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double streamingCapacity = 1;
  inline bool has_streamingcapacity() const;
  inline void clear_streamingcapacity();
  static const int kStreamingCapacityFieldNumber = 1;
  inline double streamingcapacity() const;
  inline void set_streamingcapacity(double value);

  // required double streamingThroughput = 2;
  inline bool has_streamingthroughput() const;
  inline void clear_streamingthroughput();
  static const int kStreamingThroughputFieldNumber = 2;
  inline double streamingthroughput() const;
  inline void set_streamingthroughput(double value);

  // required double randomCapacity = 3;
  inline bool has_randomcapacity() const;
  inline void clear_randomcapacity();
  static const int kRandomCapacityFieldNumber = 3;
  inline double randomcapacity() const;
  inline void set_randomcapacity(double value);

  // required double randomThroughput = 4;
  inline bool has_randomthroughput() const;
  inline void clear_randomthroughput();
  static const int kRandomThroughputFieldNumber = 4;
  inline double randomthroughput() const;
  inline void set_randomthroughput(double value);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.freeResourcesResponse)
 private:
  inline void set_has_streamingcapacity();
  inline void clear_has_streamingcapacity();
  inline void set_has_streamingthroughput();
  inline void clear_has_streamingthroughput();
  inline void set_has_randomcapacity();
  inline void clear_has_randomcapacity();
  inline void set_has_randomthroughput();
  inline void clear_has_randomthroughput();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double streamingcapacity_;
  double streamingthroughput_;
  double randomcapacity_;
  double randomthroughput_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fScheduler_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fScheduler_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fScheduler_2eproto();

  void InitAsDefaultInstance();
  static freeResourcesResponse* default_instance_;
};
// ===================================================================


// ===================================================================

// osdIdentifier

// required string uuid = 1;
inline bool osdIdentifier::has_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void osdIdentifier::set_has_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void osdIdentifier::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void osdIdentifier::clear_uuid() {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    uuid_->clear();
  }
  clear_has_uuid();
}
inline const ::std::string& osdIdentifier::uuid() const {
  return *uuid_;
}
inline void osdIdentifier::set_uuid(const ::std::string& value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void osdIdentifier::set_uuid(const char* value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void osdIdentifier::set_uuid(const char* value, size_t size) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* osdIdentifier::mutable_uuid() {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  return uuid_;
}
inline ::std::string* osdIdentifier::release_uuid() {
  clear_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uuid_;
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void osdIdentifier::set_allocated_uuid(::std::string* uuid) {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    delete uuid_;
  }
  if (uuid) {
    set_has_uuid();
    uuid_ = uuid;
  } else {
    clear_has_uuid();
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// volumeIdentifier

// required string uuid = 1;
inline bool volumeIdentifier::has_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void volumeIdentifier::set_has_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void volumeIdentifier::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void volumeIdentifier::clear_uuid() {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    uuid_->clear();
  }
  clear_has_uuid();
}
inline const ::std::string& volumeIdentifier::uuid() const {
  return *uuid_;
}
inline void volumeIdentifier::set_uuid(const ::std::string& value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void volumeIdentifier::set_uuid(const char* value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void volumeIdentifier::set_uuid(const char* value, size_t size) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* volumeIdentifier::mutable_uuid() {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  return uuid_;
}
inline ::std::string* volumeIdentifier::release_uuid() {
  clear_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uuid_;
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void volumeIdentifier::set_allocated_uuid(::std::string* uuid) {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    delete uuid_;
  }
  if (uuid) {
    set_has_uuid();
    uuid_ = uuid;
  } else {
    clear_has_uuid();
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// volumeSet

// repeated .xtreemfs.pbrpc.volumeIdentifier volumes = 1;
inline int volumeSet::volumes_size() const {
  return volumes_.size();
}
inline void volumeSet::clear_volumes() {
  volumes_.Clear();
}
inline const ::xtreemfs::pbrpc::volumeIdentifier& volumeSet::volumes(int index) const {
  return volumes_.Get(index);
}
inline ::xtreemfs::pbrpc::volumeIdentifier* volumeSet::mutable_volumes(int index) {
  return volumes_.Mutable(index);
}
inline ::xtreemfs::pbrpc::volumeIdentifier* volumeSet::add_volumes() {
  return volumes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::volumeIdentifier >&
volumeSet::volumes() const {
  return volumes_;
}
inline ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::volumeIdentifier >*
volumeSet::mutable_volumes() {
  return &volumes_;
}

// -------------------------------------------------------------------

// reservationSet

// repeated .xtreemfs.pbrpc.reservation reservations = 1;
inline int reservationSet::reservations_size() const {
  return reservations_.size();
}
inline void reservationSet::clear_reservations() {
  reservations_.Clear();
}
inline const ::xtreemfs::pbrpc::reservation& reservationSet::reservations(int index) const {
  return reservations_.Get(index);
}
inline ::xtreemfs::pbrpc::reservation* reservationSet::mutable_reservations(int index) {
  return reservations_.Mutable(index);
}
inline ::xtreemfs::pbrpc::reservation* reservationSet::add_reservations() {
  return reservations_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::reservation >&
reservationSet::reservations() const {
  return reservations_;
}
inline ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::reservation >*
reservationSet::mutable_reservations() {
  return &reservations_;
}

// -------------------------------------------------------------------

// osdSet

// repeated .xtreemfs.pbrpc.osdIdentifier osd = 1;
inline int osdSet::osd_size() const {
  return osd_.size();
}
inline void osdSet::clear_osd() {
  osd_.Clear();
}
inline const ::xtreemfs::pbrpc::osdIdentifier& osdSet::osd(int index) const {
  return osd_.Get(index);
}
inline ::xtreemfs::pbrpc::osdIdentifier* osdSet::mutable_osd(int index) {
  return osd_.Mutable(index);
}
inline ::xtreemfs::pbrpc::osdIdentifier* osdSet::add_osd() {
  return osd_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::osdIdentifier >&
osdSet::osd() const {
  return osd_;
}
inline ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::osdIdentifier >*
osdSet::mutable_osd() {
  return &osd_;
}

// -------------------------------------------------------------------

// reservation

// required .xtreemfs.pbrpc.volumeIdentifier volume = 1;
inline bool reservation::has_volume() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void reservation::set_has_volume() {
  _has_bits_[0] |= 0x00000001u;
}
inline void reservation::clear_has_volume() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void reservation::clear_volume() {
  if (volume_ != NULL) volume_->::xtreemfs::pbrpc::volumeIdentifier::Clear();
  clear_has_volume();
}
inline const ::xtreemfs::pbrpc::volumeIdentifier& reservation::volume() const {
  return volume_ != NULL ? *volume_ : *default_instance_->volume_;
}
inline ::xtreemfs::pbrpc::volumeIdentifier* reservation::mutable_volume() {
  set_has_volume();
  if (volume_ == NULL) volume_ = new ::xtreemfs::pbrpc::volumeIdentifier;
  return volume_;
}
inline ::xtreemfs::pbrpc::volumeIdentifier* reservation::release_volume() {
  clear_has_volume();
  ::xtreemfs::pbrpc::volumeIdentifier* temp = volume_;
  volume_ = NULL;
  return temp;
}
inline void reservation::set_allocated_volume(::xtreemfs::pbrpc::volumeIdentifier* volume) {
  delete volume_;
  volume_ = volume;
  if (volume) {
    set_has_volume();
  } else {
    clear_has_volume();
  }
}

// required .xtreemfs.pbrpc.reservationType type = 2;
inline bool reservation::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void reservation::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void reservation::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void reservation::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::xtreemfs::pbrpc::reservationType reservation::type() const {
  return static_cast< ::xtreemfs::pbrpc::reservationType >(type_);
}
inline void reservation::set_type(::xtreemfs::pbrpc::reservationType value) {
  assert(::xtreemfs::pbrpc::reservationType_IsValid(value));
  set_has_type();
  type_ = value;
}

// required double capacity = 3;
inline bool reservation::has_capacity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void reservation::set_has_capacity() {
  _has_bits_[0] |= 0x00000004u;
}
inline void reservation::clear_has_capacity() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void reservation::clear_capacity() {
  capacity_ = 0;
  clear_has_capacity();
}
inline double reservation::capacity() const {
  return capacity_;
}
inline void reservation::set_capacity(double value) {
  set_has_capacity();
  capacity_ = value;
}

// optional double streamingThroughput = 4;
inline bool reservation::has_streamingthroughput() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void reservation::set_has_streamingthroughput() {
  _has_bits_[0] |= 0x00000008u;
}
inline void reservation::clear_has_streamingthroughput() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void reservation::clear_streamingthroughput() {
  streamingthroughput_ = 0;
  clear_has_streamingthroughput();
}
inline double reservation::streamingthroughput() const {
  return streamingthroughput_;
}
inline void reservation::set_streamingthroughput(double value) {
  set_has_streamingthroughput();
  streamingthroughput_ = value;
}

// optional double randomThroughput = 5;
inline bool reservation::has_randomthroughput() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void reservation::set_has_randomthroughput() {
  _has_bits_[0] |= 0x00000010u;
}
inline void reservation::clear_has_randomthroughput() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void reservation::clear_randomthroughput() {
  randomthroughput_ = 0;
  clear_has_randomthroughput();
}
inline double reservation::randomthroughput() const {
  return randomthroughput_;
}
inline void reservation::set_randomthroughput(double value) {
  set_has_randomthroughput();
  randomthroughput_ = value;
}

// optional .xtreemfs.pbrpc.osdSet schedule = 6;
inline bool reservation::has_schedule() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void reservation::set_has_schedule() {
  _has_bits_[0] |= 0x00000020u;
}
inline void reservation::clear_has_schedule() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void reservation::clear_schedule() {
  if (schedule_ != NULL) schedule_->::xtreemfs::pbrpc::osdSet::Clear();
  clear_has_schedule();
}
inline const ::xtreemfs::pbrpc::osdSet& reservation::schedule() const {
  return schedule_ != NULL ? *schedule_ : *default_instance_->schedule_;
}
inline ::xtreemfs::pbrpc::osdSet* reservation::mutable_schedule() {
  set_has_schedule();
  if (schedule_ == NULL) schedule_ = new ::xtreemfs::pbrpc::osdSet;
  return schedule_;
}
inline ::xtreemfs::pbrpc::osdSet* reservation::release_schedule() {
  clear_has_schedule();
  ::xtreemfs::pbrpc::osdSet* temp = schedule_;
  schedule_ = NULL;
  return temp;
}
inline void reservation::set_allocated_schedule(::xtreemfs::pbrpc::osdSet* schedule) {
  delete schedule_;
  schedule_ = schedule;
  if (schedule) {
    set_has_schedule();
  } else {
    clear_has_schedule();
  }
}

// -------------------------------------------------------------------

// freeResourcesResponse

// required double streamingCapacity = 1;
inline bool freeResourcesResponse::has_streamingcapacity() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void freeResourcesResponse::set_has_streamingcapacity() {
  _has_bits_[0] |= 0x00000001u;
}
inline void freeResourcesResponse::clear_has_streamingcapacity() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void freeResourcesResponse::clear_streamingcapacity() {
  streamingcapacity_ = 0;
  clear_has_streamingcapacity();
}
inline double freeResourcesResponse::streamingcapacity() const {
  return streamingcapacity_;
}
inline void freeResourcesResponse::set_streamingcapacity(double value) {
  set_has_streamingcapacity();
  streamingcapacity_ = value;
}

// required double streamingThroughput = 2;
inline bool freeResourcesResponse::has_streamingthroughput() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void freeResourcesResponse::set_has_streamingthroughput() {
  _has_bits_[0] |= 0x00000002u;
}
inline void freeResourcesResponse::clear_has_streamingthroughput() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void freeResourcesResponse::clear_streamingthroughput() {
  streamingthroughput_ = 0;
  clear_has_streamingthroughput();
}
inline double freeResourcesResponse::streamingthroughput() const {
  return streamingthroughput_;
}
inline void freeResourcesResponse::set_streamingthroughput(double value) {
  set_has_streamingthroughput();
  streamingthroughput_ = value;
}

// required double randomCapacity = 3;
inline bool freeResourcesResponse::has_randomcapacity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void freeResourcesResponse::set_has_randomcapacity() {
  _has_bits_[0] |= 0x00000004u;
}
inline void freeResourcesResponse::clear_has_randomcapacity() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void freeResourcesResponse::clear_randomcapacity() {
  randomcapacity_ = 0;
  clear_has_randomcapacity();
}
inline double freeResourcesResponse::randomcapacity() const {
  return randomcapacity_;
}
inline void freeResourcesResponse::set_randomcapacity(double value) {
  set_has_randomcapacity();
  randomcapacity_ = value;
}

// required double randomThroughput = 4;
inline bool freeResourcesResponse::has_randomthroughput() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void freeResourcesResponse::set_has_randomthroughput() {
  _has_bits_[0] |= 0x00000008u;
}
inline void freeResourcesResponse::clear_has_randomthroughput() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void freeResourcesResponse::clear_randomthroughput() {
  randomthroughput_ = 0;
  clear_has_randomthroughput();
}
inline double freeResourcesResponse::randomthroughput() const {
  return randomthroughput_;
}
inline void freeResourcesResponse::set_randomthroughput(double value) {
  set_has_randomthroughput();
  randomthroughput_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pbrpc
}  // namespace xtreemfs

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::xtreemfs::pbrpc::reservationType>() {
  return ::xtreemfs::pbrpc::reservationType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_xtreemfs_2fScheduler_2eproto__INCLUDED
