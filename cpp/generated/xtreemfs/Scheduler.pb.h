// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: xtreemfs/Scheduler.proto

#ifndef PROTOBUF_xtreemfs_2fScheduler_2eproto__INCLUDED
#define PROTOBUF_xtreemfs_2fScheduler_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/service.h>
#include "include/PBRPC.pb.h"
#include "include/Common.pb.h"
#include "xtreemfs/GlobalTypes.pb.h"
// @@protoc_insertion_point(includes)

namespace xtreemfs {
namespace pbrpc {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_xtreemfs_2fScheduler_2eproto();
void protobuf_AssignDesc_xtreemfs_2fScheduler_2eproto();
void protobuf_ShutdownFile_xtreemfs_2fScheduler_2eproto();

class osdIdentifier;
class volumeIdentifier;
class volumeSet;
class reservation;
class reservationSet;
class osdSet;

enum reservationType {
  STREAMING_RESERVATION = 1,
  RANDOM_IO_RESERVATION = 2,
  BEST_EFFORT_RESERVATION = 3,
  COLD_STORAGE_RESERVATION = 4
};
bool reservationType_IsValid(int value);
const reservationType reservationType_MIN = STREAMING_RESERVATION;
const reservationType reservationType_MAX = COLD_STORAGE_RESERVATION;
const int reservationType_ARRAYSIZE = reservationType_MAX + 1;

const ::google::protobuf::EnumDescriptor* reservationType_descriptor();
inline const ::std::string& reservationType_Name(reservationType value) {
  return ::google::protobuf::internal::NameOfEnum(
    reservationType_descriptor(), value);
}
inline bool reservationType_Parse(
    const ::std::string& name, reservationType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<reservationType>(
    reservationType_descriptor(), name, value);
}
// ===================================================================

class osdIdentifier : public ::google::protobuf::Message {
 public:
  osdIdentifier();
  virtual ~osdIdentifier();
  
  osdIdentifier(const osdIdentifier& from);
  
  inline osdIdentifier& operator=(const osdIdentifier& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const osdIdentifier& default_instance();
  
  void Swap(osdIdentifier* other);
  
  // implements Message ----------------------------------------------
  
  osdIdentifier* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const osdIdentifier& from);
  void MergeFrom(const osdIdentifier& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string uuid = 1;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 1;
  inline const ::std::string& uuid() const;
  inline void set_uuid(const ::std::string& value);
  inline void set_uuid(const char* value);
  inline void set_uuid(const char* value, size_t size);
  inline ::std::string* mutable_uuid();
  
  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.osdIdentifier)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* uuid_;
  static const ::std::string _default_uuid_;
  friend void  protobuf_AddDesc_xtreemfs_2fScheduler_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fScheduler_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fScheduler_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static osdIdentifier* default_instance_;
};
// -------------------------------------------------------------------

class volumeIdentifier : public ::google::protobuf::Message {
 public:
  volumeIdentifier();
  virtual ~volumeIdentifier();
  
  volumeIdentifier(const volumeIdentifier& from);
  
  inline volumeIdentifier& operator=(const volumeIdentifier& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const volumeIdentifier& default_instance();
  
  void Swap(volumeIdentifier* other);
  
  // implements Message ----------------------------------------------
  
  volumeIdentifier* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const volumeIdentifier& from);
  void MergeFrom(const volumeIdentifier& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string uuid = 1;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 1;
  inline const ::std::string& uuid() const;
  inline void set_uuid(const ::std::string& value);
  inline void set_uuid(const char* value);
  inline void set_uuid(const char* value, size_t size);
  inline ::std::string* mutable_uuid();
  
  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.volumeIdentifier)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* uuid_;
  static const ::std::string _default_uuid_;
  friend void  protobuf_AddDesc_xtreemfs_2fScheduler_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fScheduler_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fScheduler_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static volumeIdentifier* default_instance_;
};
// -------------------------------------------------------------------

class volumeSet : public ::google::protobuf::Message {
 public:
  volumeSet();
  virtual ~volumeSet();
  
  volumeSet(const volumeSet& from);
  
  inline volumeSet& operator=(const volumeSet& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const volumeSet& default_instance();
  
  void Swap(volumeSet* other);
  
  // implements Message ----------------------------------------------
  
  volumeSet* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const volumeSet& from);
  void MergeFrom(const volumeSet& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .xtreemfs.pbrpc.volumeIdentifier volumes = 1;
  inline int volumes_size() const;
  inline void clear_volumes();
  static const int kVolumesFieldNumber = 1;
  inline const ::xtreemfs::pbrpc::volumeIdentifier& volumes(int index) const;
  inline ::xtreemfs::pbrpc::volumeIdentifier* mutable_volumes(int index);
  inline ::xtreemfs::pbrpc::volumeIdentifier* add_volumes();
  inline const ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::volumeIdentifier >&
      volumes() const;
  inline ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::volumeIdentifier >*
      mutable_volumes();
  
  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.volumeSet)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::volumeIdentifier > volumes_;
  friend void  protobuf_AddDesc_xtreemfs_2fScheduler_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fScheduler_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fScheduler_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static volumeSet* default_instance_;
};
// -------------------------------------------------------------------

class reservation : public ::google::protobuf::Message {
 public:
  reservation();
  virtual ~reservation();
  
  reservation(const reservation& from);
  
  inline reservation& operator=(const reservation& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const reservation& default_instance();
  
  void Swap(reservation* other);
  
  // implements Message ----------------------------------------------
  
  reservation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const reservation& from);
  void MergeFrom(const reservation& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .xtreemfs.pbrpc.volumeIdentifier volume = 1;
  inline bool has_volume() const;
  inline void clear_volume();
  static const int kVolumeFieldNumber = 1;
  inline const ::xtreemfs::pbrpc::volumeIdentifier& volume() const;
  inline ::xtreemfs::pbrpc::volumeIdentifier* mutable_volume();
  
  // required .xtreemfs.pbrpc.reservationType type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline xtreemfs::pbrpc::reservationType type() const;
  inline void set_type(xtreemfs::pbrpc::reservationType value);
  
  // required double capacity = 3;
  inline bool has_capacity() const;
  inline void clear_capacity();
  static const int kCapacityFieldNumber = 3;
  inline double capacity() const;
  inline void set_capacity(double value);
  
  // optional double streamingThroughput = 4;
  inline bool has_streamingthroughput() const;
  inline void clear_streamingthroughput();
  static const int kStreamingThroughputFieldNumber = 4;
  inline double streamingthroughput() const;
  inline void set_streamingthroughput(double value);
  
  // optional double randomThroughput = 5;
  inline bool has_randomthroughput() const;
  inline void clear_randomthroughput();
  static const int kRandomThroughputFieldNumber = 5;
  inline double randomthroughput() const;
  inline void set_randomthroughput(double value);
  
  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.reservation)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::xtreemfs::pbrpc::volumeIdentifier* volume_;
  int type_;
  double capacity_;
  double streamingthroughput_;
  double randomthroughput_;
  friend void  protobuf_AddDesc_xtreemfs_2fScheduler_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fScheduler_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fScheduler_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static reservation* default_instance_;
};
// -------------------------------------------------------------------

class reservationSet : public ::google::protobuf::Message {
 public:
  reservationSet();
  virtual ~reservationSet();
  
  reservationSet(const reservationSet& from);
  
  inline reservationSet& operator=(const reservationSet& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const reservationSet& default_instance();
  
  void Swap(reservationSet* other);
  
  // implements Message ----------------------------------------------
  
  reservationSet* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const reservationSet& from);
  void MergeFrom(const reservationSet& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .xtreemfs.pbrpc.reservation reservations = 1;
  inline int reservations_size() const;
  inline void clear_reservations();
  static const int kReservationsFieldNumber = 1;
  inline const ::xtreemfs::pbrpc::reservation& reservations(int index) const;
  inline ::xtreemfs::pbrpc::reservation* mutable_reservations(int index);
  inline ::xtreemfs::pbrpc::reservation* add_reservations();
  inline const ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::reservation >&
      reservations() const;
  inline ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::reservation >*
      mutable_reservations();
  
  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.reservationSet)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::reservation > reservations_;
  friend void  protobuf_AddDesc_xtreemfs_2fScheduler_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fScheduler_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fScheduler_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static reservationSet* default_instance_;
};
// -------------------------------------------------------------------

class osdSet : public ::google::protobuf::Message {
 public:
  osdSet();
  virtual ~osdSet();
  
  osdSet(const osdSet& from);
  
  inline osdSet& operator=(const osdSet& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const osdSet& default_instance();
  
  void Swap(osdSet* other);
  
  // implements Message ----------------------------------------------
  
  osdSet* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const osdSet& from);
  void MergeFrom(const osdSet& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .xtreemfs.pbrpc.osdIdentifier osd = 1;
  inline int osd_size() const;
  inline void clear_osd();
  static const int kOsdFieldNumber = 1;
  inline const ::xtreemfs::pbrpc::osdIdentifier& osd(int index) const;
  inline ::xtreemfs::pbrpc::osdIdentifier* mutable_osd(int index);
  inline ::xtreemfs::pbrpc::osdIdentifier* add_osd();
  inline const ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::osdIdentifier >&
      osd() const;
  inline ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::osdIdentifier >*
      mutable_osd();
  
  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.osdSet)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::osdIdentifier > osd_;
  friend void  protobuf_AddDesc_xtreemfs_2fScheduler_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fScheduler_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fScheduler_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static osdSet* default_instance_;
};
// ===================================================================

class SchedulerService_Stub;

class SchedulerService : public ::google::protobuf::Service {
 protected:
  // This class should be treated as an abstract interface.
  inline SchedulerService() {};
 public:
  virtual ~SchedulerService();
  
  typedef SchedulerService_Stub Stub;
  
  static const ::google::protobuf::ServiceDescriptor* descriptor();
  
  virtual void scheduleReservation(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::reservation* request,
                       ::xtreemfs::pbrpc::osdSet* response,
                       ::google::protobuf::Closure* done);
  virtual void removeReservation(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::volumeIdentifier* request,
                       ::xtreemfs::pbrpc::emptyResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void getSchedule(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::volumeIdentifier* request,
                       ::xtreemfs::pbrpc::osdSet* response,
                       ::google::protobuf::Closure* done);
  virtual void getVolumes(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::osdIdentifier* request,
                       ::xtreemfs::pbrpc::volumeSet* response,
                       ::google::protobuf::Closure* done);
  virtual void getAllVolumes(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::emptyRequest* request,
                       ::xtreemfs::pbrpc::reservationSet* response,
                       ::google::protobuf::Closure* done);
  
  // implements Service ----------------------------------------------
  
  const ::google::protobuf::ServiceDescriptor* GetDescriptor();
  void CallMethod(const ::google::protobuf::MethodDescriptor* method,
                  ::google::protobuf::RpcController* controller,
                  const ::google::protobuf::Message* request,
                  ::google::protobuf::Message* response,
                  ::google::protobuf::Closure* done);
  const ::google::protobuf::Message& GetRequestPrototype(
    const ::google::protobuf::MethodDescriptor* method) const;
  const ::google::protobuf::Message& GetResponsePrototype(
    const ::google::protobuf::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(SchedulerService);
};

class SchedulerService_Stub : public SchedulerService {
 public:
  SchedulerService_Stub(::google::protobuf::RpcChannel* channel);
  SchedulerService_Stub(::google::protobuf::RpcChannel* channel,
                   ::google::protobuf::Service::ChannelOwnership ownership);
  ~SchedulerService_Stub();
  
  inline ::google::protobuf::RpcChannel* channel() { return channel_; }
  
  // implements SchedulerService ------------------------------------------
  
  void scheduleReservation(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::reservation* request,
                       ::xtreemfs::pbrpc::osdSet* response,
                       ::google::protobuf::Closure* done);
  void removeReservation(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::volumeIdentifier* request,
                       ::xtreemfs::pbrpc::emptyResponse* response,
                       ::google::protobuf::Closure* done);
  void getSchedule(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::volumeIdentifier* request,
                       ::xtreemfs::pbrpc::osdSet* response,
                       ::google::protobuf::Closure* done);
  void getVolumes(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::osdIdentifier* request,
                       ::xtreemfs::pbrpc::volumeSet* response,
                       ::google::protobuf::Closure* done);
  void getAllVolumes(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::emptyRequest* request,
                       ::xtreemfs::pbrpc::reservationSet* response,
                       ::google::protobuf::Closure* done);
 private:
  ::google::protobuf::RpcChannel* channel_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(SchedulerService_Stub);
};


// ===================================================================


// ===================================================================

// osdIdentifier

// required string uuid = 1;
inline bool osdIdentifier::has_uuid() const {
  return _has_bit(0);
}
inline void osdIdentifier::clear_uuid() {
  if (uuid_ != &_default_uuid_) {
    uuid_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& osdIdentifier::uuid() const {
  return *uuid_;
}
inline void osdIdentifier::set_uuid(const ::std::string& value) {
  _set_bit(0);
  if (uuid_ == &_default_uuid_) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void osdIdentifier::set_uuid(const char* value) {
  _set_bit(0);
  if (uuid_ == &_default_uuid_) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void osdIdentifier::set_uuid(const char* value, size_t size) {
  _set_bit(0);
  if (uuid_ == &_default_uuid_) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* osdIdentifier::mutable_uuid() {
  _set_bit(0);
  if (uuid_ == &_default_uuid_) {
    uuid_ = new ::std::string;
  }
  return uuid_;
}

// -------------------------------------------------------------------

// volumeIdentifier

// required string uuid = 1;
inline bool volumeIdentifier::has_uuid() const {
  return _has_bit(0);
}
inline void volumeIdentifier::clear_uuid() {
  if (uuid_ != &_default_uuid_) {
    uuid_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& volumeIdentifier::uuid() const {
  return *uuid_;
}
inline void volumeIdentifier::set_uuid(const ::std::string& value) {
  _set_bit(0);
  if (uuid_ == &_default_uuid_) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void volumeIdentifier::set_uuid(const char* value) {
  _set_bit(0);
  if (uuid_ == &_default_uuid_) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void volumeIdentifier::set_uuid(const char* value, size_t size) {
  _set_bit(0);
  if (uuid_ == &_default_uuid_) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* volumeIdentifier::mutable_uuid() {
  _set_bit(0);
  if (uuid_ == &_default_uuid_) {
    uuid_ = new ::std::string;
  }
  return uuid_;
}

// -------------------------------------------------------------------

// volumeSet

// repeated .xtreemfs.pbrpc.volumeIdentifier volumes = 1;
inline int volumeSet::volumes_size() const {
  return volumes_.size();
}
inline void volumeSet::clear_volumes() {
  volumes_.Clear();
}
inline const ::xtreemfs::pbrpc::volumeIdentifier& volumeSet::volumes(int index) const {
  return volumes_.Get(index);
}
inline ::xtreemfs::pbrpc::volumeIdentifier* volumeSet::mutable_volumes(int index) {
  return volumes_.Mutable(index);
}
inline ::xtreemfs::pbrpc::volumeIdentifier* volumeSet::add_volumes() {
  return volumes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::volumeIdentifier >&
volumeSet::volumes() const {
  return volumes_;
}
inline ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::volumeIdentifier >*
volumeSet::mutable_volumes() {
  return &volumes_;
}

// -------------------------------------------------------------------

// reservation

// required .xtreemfs.pbrpc.volumeIdentifier volume = 1;
inline bool reservation::has_volume() const {
  return _has_bit(0);
}
inline void reservation::clear_volume() {
  if (volume_ != NULL) volume_->::xtreemfs::pbrpc::volumeIdentifier::Clear();
  _clear_bit(0);
}
inline const ::xtreemfs::pbrpc::volumeIdentifier& reservation::volume() const {
  return volume_ != NULL ? *volume_ : *default_instance_->volume_;
}
inline ::xtreemfs::pbrpc::volumeIdentifier* reservation::mutable_volume() {
  _set_bit(0);
  if (volume_ == NULL) volume_ = new ::xtreemfs::pbrpc::volumeIdentifier;
  return volume_;
}

// required .xtreemfs.pbrpc.reservationType type = 2;
inline bool reservation::has_type() const {
  return _has_bit(1);
}
inline void reservation::clear_type() {
  type_ = 1;
  _clear_bit(1);
}
inline xtreemfs::pbrpc::reservationType reservation::type() const {
  return static_cast< xtreemfs::pbrpc::reservationType >(type_);
}
inline void reservation::set_type(xtreemfs::pbrpc::reservationType value) {
  GOOGLE_DCHECK(xtreemfs::pbrpc::reservationType_IsValid(value));
  _set_bit(1);
  type_ = value;
}

// required double capacity = 3;
inline bool reservation::has_capacity() const {
  return _has_bit(2);
}
inline void reservation::clear_capacity() {
  capacity_ = 0;
  _clear_bit(2);
}
inline double reservation::capacity() const {
  return capacity_;
}
inline void reservation::set_capacity(double value) {
  _set_bit(2);
  capacity_ = value;
}

// optional double streamingThroughput = 4;
inline bool reservation::has_streamingthroughput() const {
  return _has_bit(3);
}
inline void reservation::clear_streamingthroughput() {
  streamingthroughput_ = 0;
  _clear_bit(3);
}
inline double reservation::streamingthroughput() const {
  return streamingthroughput_;
}
inline void reservation::set_streamingthroughput(double value) {
  _set_bit(3);
  streamingthroughput_ = value;
}

// optional double randomThroughput = 5;
inline bool reservation::has_randomthroughput() const {
  return _has_bit(4);
}
inline void reservation::clear_randomthroughput() {
  randomthroughput_ = 0;
  _clear_bit(4);
}
inline double reservation::randomthroughput() const {
  return randomthroughput_;
}
inline void reservation::set_randomthroughput(double value) {
  _set_bit(4);
  randomthroughput_ = value;
}

// -------------------------------------------------------------------

// reservationSet

// repeated .xtreemfs.pbrpc.reservation reservations = 1;
inline int reservationSet::reservations_size() const {
  return reservations_.size();
}
inline void reservationSet::clear_reservations() {
  reservations_.Clear();
}
inline const ::xtreemfs::pbrpc::reservation& reservationSet::reservations(int index) const {
  return reservations_.Get(index);
}
inline ::xtreemfs::pbrpc::reservation* reservationSet::mutable_reservations(int index) {
  return reservations_.Mutable(index);
}
inline ::xtreemfs::pbrpc::reservation* reservationSet::add_reservations() {
  return reservations_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::reservation >&
reservationSet::reservations() const {
  return reservations_;
}
inline ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::reservation >*
reservationSet::mutable_reservations() {
  return &reservations_;
}

// -------------------------------------------------------------------

// osdSet

// repeated .xtreemfs.pbrpc.osdIdentifier osd = 1;
inline int osdSet::osd_size() const {
  return osd_.size();
}
inline void osdSet::clear_osd() {
  osd_.Clear();
}
inline const ::xtreemfs::pbrpc::osdIdentifier& osdSet::osd(int index) const {
  return osd_.Get(index);
}
inline ::xtreemfs::pbrpc::osdIdentifier* osdSet::mutable_osd(int index) {
  return osd_.Mutable(index);
}
inline ::xtreemfs::pbrpc::osdIdentifier* osdSet::add_osd() {
  return osd_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::osdIdentifier >&
osdSet::osd() const {
  return osd_;
}
inline ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::osdIdentifier >*
osdSet::mutable_osd() {
  return &osd_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pbrpc
}  // namespace xtreemfs

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< xtreemfs::pbrpc::reservationType>() {
  return xtreemfs::pbrpc::reservationType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_xtreemfs_2fScheduler_2eproto__INCLUDED
