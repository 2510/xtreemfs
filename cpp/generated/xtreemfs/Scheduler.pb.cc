// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: xtreemfs/Scheduler.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "xtreemfs/Scheduler.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace xtreemfs {
namespace pbrpc {

namespace {

const ::google::protobuf::Descriptor* osdIdentifier_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  osdIdentifier_reflection_ = NULL;
const ::google::protobuf::Descriptor* volumeIdentifier_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  volumeIdentifier_reflection_ = NULL;
const ::google::protobuf::Descriptor* volumeSet_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  volumeSet_reflection_ = NULL;
const ::google::protobuf::Descriptor* reservation_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  reservation_reflection_ = NULL;
const ::google::protobuf::Descriptor* reservationSet_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  reservationSet_reflection_ = NULL;
const ::google::protobuf::Descriptor* osdSet_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  osdSet_reflection_ = NULL;
const ::google::protobuf::Descriptor* freeResourcesResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  freeResourcesResponse_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* reservationType_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_xtreemfs_2fScheduler_2eproto() {
  protobuf_AddDesc_xtreemfs_2fScheduler_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "xtreemfs/Scheduler.proto");
  GOOGLE_CHECK(file != NULL);
  osdIdentifier_descriptor_ = file->message_type(0);
  static const int osdIdentifier_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(osdIdentifier, uuid_),
  };
  osdIdentifier_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      osdIdentifier_descriptor_,
      osdIdentifier::default_instance_,
      osdIdentifier_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(osdIdentifier, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(osdIdentifier, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(osdIdentifier));
  volumeIdentifier_descriptor_ = file->message_type(1);
  static const int volumeIdentifier_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(volumeIdentifier, uuid_),
  };
  volumeIdentifier_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      volumeIdentifier_descriptor_,
      volumeIdentifier::default_instance_,
      volumeIdentifier_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(volumeIdentifier, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(volumeIdentifier, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(volumeIdentifier));
  volumeSet_descriptor_ = file->message_type(2);
  static const int volumeSet_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(volumeSet, volumes_),
  };
  volumeSet_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      volumeSet_descriptor_,
      volumeSet::default_instance_,
      volumeSet_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(volumeSet, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(volumeSet, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(volumeSet));
  reservation_descriptor_ = file->message_type(3);
  static const int reservation_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(reservation, volume_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(reservation, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(reservation, capacity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(reservation, streamingthroughput_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(reservation, randomthroughput_),
  };
  reservation_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      reservation_descriptor_,
      reservation::default_instance_,
      reservation_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(reservation, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(reservation, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(reservation));
  reservationSet_descriptor_ = file->message_type(4);
  static const int reservationSet_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(reservationSet, reservations_),
  };
  reservationSet_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      reservationSet_descriptor_,
      reservationSet::default_instance_,
      reservationSet_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(reservationSet, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(reservationSet, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(reservationSet));
  osdSet_descriptor_ = file->message_type(5);
  static const int osdSet_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(osdSet, osd_),
  };
  osdSet_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      osdSet_descriptor_,
      osdSet::default_instance_,
      osdSet_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(osdSet, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(osdSet, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(osdSet));
  freeResourcesResponse_descriptor_ = file->message_type(6);
  static const int freeResourcesResponse_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(freeResourcesResponse, streamingcapacity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(freeResourcesResponse, streamingthroughput_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(freeResourcesResponse, randomcapacity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(freeResourcesResponse, randomthroughput_),
  };
  freeResourcesResponse_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      freeResourcesResponse_descriptor_,
      freeResourcesResponse::default_instance_,
      freeResourcesResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(freeResourcesResponse, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(freeResourcesResponse, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(freeResourcesResponse));
  reservationType_descriptor_ = file->enum_type(0);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_xtreemfs_2fScheduler_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    osdIdentifier_descriptor_, &osdIdentifier::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    volumeIdentifier_descriptor_, &volumeIdentifier::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    volumeSet_descriptor_, &volumeSet::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    reservation_descriptor_, &reservation::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    reservationSet_descriptor_, &reservationSet::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    osdSet_descriptor_, &osdSet::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    freeResourcesResponse_descriptor_, &freeResourcesResponse::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_xtreemfs_2fScheduler_2eproto() {
  delete osdIdentifier::default_instance_;
  delete osdIdentifier_reflection_;
  delete volumeIdentifier::default_instance_;
  delete volumeIdentifier_reflection_;
  delete volumeSet::default_instance_;
  delete volumeSet_reflection_;
  delete reservation::default_instance_;
  delete reservation_reflection_;
  delete reservationSet::default_instance_;
  delete reservationSet_reflection_;
  delete osdSet::default_instance_;
  delete osdSet_reflection_;
  delete freeResourcesResponse::default_instance_;
  delete freeResourcesResponse_reflection_;
}

void protobuf_AddDesc_xtreemfs_2fScheduler_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::xtreemfs::pbrpc::protobuf_AddDesc_include_2fPBRPC_2eproto();
  ::xtreemfs::pbrpc::protobuf_AddDesc_include_2fCommon_2eproto();
  ::xtreemfs::pbrpc::protobuf_AddDesc_xtreemfs_2fGlobalTypes_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\030xtreemfs/Scheduler.proto\022\016xtreemfs.pbr"
    "pc\032\023include/PBRPC.proto\032\024include/Common."
    "proto\032\032xtreemfs/GlobalTypes.proto\"\035\n\rosd"
    "Identifier\022\014\n\004uuid\030\001 \002(\t\" \n\020volumeIdenti"
    "fier\022\014\n\004uuid\030\001 \002(\t\">\n\tvolumeSet\0221\n\007volum"
    "es\030\001 \003(\0132 .xtreemfs.pbrpc.volumeIdentifi"
    "er\"\267\001\n\013reservation\0220\n\006volume\030\001 \002(\0132 .xtr"
    "eemfs.pbrpc.volumeIdentifier\022-\n\004type\030\002 \002"
    "(\0162\037.xtreemfs.pbrpc.reservationType\022\020\n\010c"
    "apacity\030\003 \002(\001\022\033\n\023streamingThroughput\030\004 \001"
    "(\001\022\030\n\020randomThroughput\030\005 \001(\001\"C\n\016reservat"
    "ionSet\0221\n\014reservations\030\001 \003(\0132\033.xtreemfs."
    "pbrpc.reservation\"4\n\006osdSet\022*\n\003osd\030\001 \003(\013"
    "2\035.xtreemfs.pbrpc.osdIdentifier\"\201\001\n\025free"
    "ResourcesResponse\022\031\n\021streamingCapacity\030\001"
    " \002(\001\022\033\n\023streamingThroughput\030\002 \002(\001\022\026\n\016ran"
    "domCapacity\030\003 \002(\001\022\030\n\020randomThroughput\030\004 "
    "\002(\001*\202\001\n\017reservationType\022\031\n\025STREAMING_RES"
    "ERVATION\020\001\022\031\n\025RANDOM_IO_RESERVATION\020\002\022\033\n"
    "\027BEST_EFFORT_RESERVATION\020\003\022\034\n\030COLD_STORA"
    "GE_RESERVATION\020\0042\254\004\n\020SchedulerService\022S\n"
    "\023scheduleReservation\022\033.xtreemfs.pbrpc.re"
    "servation\032\026.xtreemfs.pbrpc.osdSet\"\007\215\265\030e\000"
    "\000\000\022]\n\021removeReservation\022 .xtreemfs.pbrpc"
    ".volumeIdentifier\032\035.xtreemfs.pbrpc.empty"
    "Response\"\007\215\265\030f\000\000\000\022P\n\013getSchedule\022 .xtree"
    "mfs.pbrpc.volumeIdentifier\032\026.xtreemfs.pb"
    "rpc.osdSet\"\007\215\265\030g\000\000\000\022O\n\ngetVolumes\022\035.xtre"
    "emfs.pbrpc.osdIdentifier\032\031.xtreemfs.pbrp"
    "c.volumeSet\"\007\215\265\030h\000\000\000\022V\n\rgetAllVolumes\022\034."
    "xtreemfs.pbrpc.emptyRequest\032\036.xtreemfs.p"
    "brpc.reservationSet\"\007\215\265\030i\000\000\000\022`\n\020getFreeR"
    "esources\022\034.xtreemfs.pbrpc.emptyRequest\032%"
    ".xtreemfs.pbrpc.freeResourcesResponse\"\007\215"
    "\265\030j\000\000\000\032\007\225\265\030A\234\000\000B(\n&org.xtreemfs.pbrpc.ge"
    "neratedinterfaces", 1417);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "xtreemfs/Scheduler.proto", &protobuf_RegisterTypes);
  osdIdentifier::default_instance_ = new osdIdentifier();
  volumeIdentifier::default_instance_ = new volumeIdentifier();
  volumeSet::default_instance_ = new volumeSet();
  reservation::default_instance_ = new reservation();
  reservationSet::default_instance_ = new reservationSet();
  osdSet::default_instance_ = new osdSet();
  freeResourcesResponse::default_instance_ = new freeResourcesResponse();
  osdIdentifier::default_instance_->InitAsDefaultInstance();
  volumeIdentifier::default_instance_->InitAsDefaultInstance();
  volumeSet::default_instance_->InitAsDefaultInstance();
  reservation::default_instance_->InitAsDefaultInstance();
  reservationSet::default_instance_->InitAsDefaultInstance();
  osdSet::default_instance_->InitAsDefaultInstance();
  freeResourcesResponse::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_xtreemfs_2fScheduler_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_xtreemfs_2fScheduler_2eproto {
  StaticDescriptorInitializer_xtreemfs_2fScheduler_2eproto() {
    protobuf_AddDesc_xtreemfs_2fScheduler_2eproto();
  }
} static_descriptor_initializer_xtreemfs_2fScheduler_2eproto_;
const ::google::protobuf::EnumDescriptor* reservationType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return reservationType_descriptor_;
}
bool reservationType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int osdIdentifier::kUuidFieldNumber;
#endif  // !_MSC_VER

osdIdentifier::osdIdentifier()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void osdIdentifier::InitAsDefaultInstance() {
}

osdIdentifier::osdIdentifier(const osdIdentifier& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void osdIdentifier::SharedCtor() {
  _cached_size_ = 0;
  uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

osdIdentifier::~osdIdentifier() {
  SharedDtor();
}

void osdIdentifier::SharedDtor() {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    delete uuid_;
  }
  if (this != default_instance_) {
  }
}

void osdIdentifier::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* osdIdentifier::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return osdIdentifier_descriptor_;
}

const osdIdentifier& osdIdentifier::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_xtreemfs_2fScheduler_2eproto();
  return *default_instance_;
}

osdIdentifier* osdIdentifier::default_instance_ = NULL;

osdIdentifier* osdIdentifier::New() const {
  return new osdIdentifier;
}

void osdIdentifier::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_uuid()) {
      if (uuid_ != &::google::protobuf::internal::kEmptyString) {
        uuid_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool osdIdentifier::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string uuid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_uuid()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->uuid().data(), this->uuid().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void osdIdentifier::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string uuid = 1;
  if (has_uuid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->uuid().data(), this->uuid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->uuid(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* osdIdentifier::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string uuid = 1;
  if (has_uuid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->uuid().data(), this->uuid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->uuid(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int osdIdentifier::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string uuid = 1;
    if (has_uuid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->uuid());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void osdIdentifier::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const osdIdentifier* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const osdIdentifier*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void osdIdentifier::MergeFrom(const osdIdentifier& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uuid()) {
      set_uuid(from.uuid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void osdIdentifier::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void osdIdentifier::CopyFrom(const osdIdentifier& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool osdIdentifier::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void osdIdentifier::Swap(osdIdentifier* other) {
  if (other != this) {
    std::swap(uuid_, other->uuid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata osdIdentifier::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = osdIdentifier_descriptor_;
  metadata.reflection = osdIdentifier_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int volumeIdentifier::kUuidFieldNumber;
#endif  // !_MSC_VER

volumeIdentifier::volumeIdentifier()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void volumeIdentifier::InitAsDefaultInstance() {
}

volumeIdentifier::volumeIdentifier(const volumeIdentifier& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void volumeIdentifier::SharedCtor() {
  _cached_size_ = 0;
  uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

volumeIdentifier::~volumeIdentifier() {
  SharedDtor();
}

void volumeIdentifier::SharedDtor() {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    delete uuid_;
  }
  if (this != default_instance_) {
  }
}

void volumeIdentifier::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* volumeIdentifier::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return volumeIdentifier_descriptor_;
}

const volumeIdentifier& volumeIdentifier::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_xtreemfs_2fScheduler_2eproto();
  return *default_instance_;
}

volumeIdentifier* volumeIdentifier::default_instance_ = NULL;

volumeIdentifier* volumeIdentifier::New() const {
  return new volumeIdentifier;
}

void volumeIdentifier::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_uuid()) {
      if (uuid_ != &::google::protobuf::internal::kEmptyString) {
        uuid_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool volumeIdentifier::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string uuid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_uuid()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->uuid().data(), this->uuid().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void volumeIdentifier::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string uuid = 1;
  if (has_uuid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->uuid().data(), this->uuid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->uuid(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* volumeIdentifier::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string uuid = 1;
  if (has_uuid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->uuid().data(), this->uuid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->uuid(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int volumeIdentifier::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string uuid = 1;
    if (has_uuid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->uuid());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void volumeIdentifier::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const volumeIdentifier* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const volumeIdentifier*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void volumeIdentifier::MergeFrom(const volumeIdentifier& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uuid()) {
      set_uuid(from.uuid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void volumeIdentifier::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void volumeIdentifier::CopyFrom(const volumeIdentifier& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool volumeIdentifier::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void volumeIdentifier::Swap(volumeIdentifier* other) {
  if (other != this) {
    std::swap(uuid_, other->uuid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata volumeIdentifier::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = volumeIdentifier_descriptor_;
  metadata.reflection = volumeIdentifier_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int volumeSet::kVolumesFieldNumber;
#endif  // !_MSC_VER

volumeSet::volumeSet()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void volumeSet::InitAsDefaultInstance() {
}

volumeSet::volumeSet(const volumeSet& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void volumeSet::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

volumeSet::~volumeSet() {
  SharedDtor();
}

void volumeSet::SharedDtor() {
  if (this != default_instance_) {
  }
}

void volumeSet::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* volumeSet::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return volumeSet_descriptor_;
}

const volumeSet& volumeSet::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_xtreemfs_2fScheduler_2eproto();
  return *default_instance_;
}

volumeSet* volumeSet::default_instance_ = NULL;

volumeSet* volumeSet::New() const {
  return new volumeSet;
}

void volumeSet::Clear() {
  volumes_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool volumeSet::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .xtreemfs.pbrpc.volumeIdentifier volumes = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_volumes:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_volumes()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_volumes;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void volumeSet::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .xtreemfs.pbrpc.volumeIdentifier volumes = 1;
  for (int i = 0; i < this->volumes_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->volumes(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* volumeSet::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .xtreemfs.pbrpc.volumeIdentifier volumes = 1;
  for (int i = 0; i < this->volumes_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->volumes(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int volumeSet::ByteSize() const {
  int total_size = 0;

  // repeated .xtreemfs.pbrpc.volumeIdentifier volumes = 1;
  total_size += 1 * this->volumes_size();
  for (int i = 0; i < this->volumes_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->volumes(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void volumeSet::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const volumeSet* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const volumeSet*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void volumeSet::MergeFrom(const volumeSet& from) {
  GOOGLE_CHECK_NE(&from, this);
  volumes_.MergeFrom(from.volumes_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void volumeSet::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void volumeSet::CopyFrom(const volumeSet& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool volumeSet::IsInitialized() const {

  for (int i = 0; i < volumes_size(); i++) {
    if (!this->volumes(i).IsInitialized()) return false;
  }
  return true;
}

void volumeSet::Swap(volumeSet* other) {
  if (other != this) {
    volumes_.Swap(&other->volumes_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata volumeSet::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = volumeSet_descriptor_;
  metadata.reflection = volumeSet_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int reservation::kVolumeFieldNumber;
const int reservation::kTypeFieldNumber;
const int reservation::kCapacityFieldNumber;
const int reservation::kStreamingThroughputFieldNumber;
const int reservation::kRandomThroughputFieldNumber;
#endif  // !_MSC_VER

reservation::reservation()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void reservation::InitAsDefaultInstance() {
  volume_ = const_cast< ::xtreemfs::pbrpc::volumeIdentifier*>(&::xtreemfs::pbrpc::volumeIdentifier::default_instance());
}

reservation::reservation(const reservation& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void reservation::SharedCtor() {
  _cached_size_ = 0;
  volume_ = NULL;
  type_ = 1;
  capacity_ = 0;
  streamingthroughput_ = 0;
  randomthroughput_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

reservation::~reservation() {
  SharedDtor();
}

void reservation::SharedDtor() {
  if (this != default_instance_) {
    delete volume_;
  }
}

void reservation::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* reservation::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return reservation_descriptor_;
}

const reservation& reservation::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_xtreemfs_2fScheduler_2eproto();
  return *default_instance_;
}

reservation* reservation::default_instance_ = NULL;

reservation* reservation::New() const {
  return new reservation;
}

void reservation::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_volume()) {
      if (volume_ != NULL) volume_->::xtreemfs::pbrpc::volumeIdentifier::Clear();
    }
    type_ = 1;
    capacity_ = 0;
    streamingthroughput_ = 0;
    randomthroughput_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool reservation::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .xtreemfs.pbrpc.volumeIdentifier volume = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_volume()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_type;
        break;
      }

      // required .xtreemfs.pbrpc.reservationType type = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::xtreemfs::pbrpc::reservationType_IsValid(value)) {
            set_type(static_cast< ::xtreemfs::pbrpc::reservationType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(25)) goto parse_capacity;
        break;
      }

      // required double capacity = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_capacity:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &capacity_)));
          set_has_capacity();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(33)) goto parse_streamingThroughput;
        break;
      }

      // optional double streamingThroughput = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_streamingThroughput:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &streamingthroughput_)));
          set_has_streamingthroughput();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(41)) goto parse_randomThroughput;
        break;
      }

      // optional double randomThroughput = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_randomThroughput:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &randomthroughput_)));
          set_has_randomthroughput();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void reservation::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .xtreemfs.pbrpc.volumeIdentifier volume = 1;
  if (has_volume()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->volume(), output);
  }

  // required .xtreemfs.pbrpc.reservationType type = 2;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->type(), output);
  }

  // required double capacity = 3;
  if (has_capacity()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->capacity(), output);
  }

  // optional double streamingThroughput = 4;
  if (has_streamingthroughput()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->streamingthroughput(), output);
  }

  // optional double randomThroughput = 5;
  if (has_randomthroughput()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(5, this->randomthroughput(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* reservation::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .xtreemfs.pbrpc.volumeIdentifier volume = 1;
  if (has_volume()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->volume(), target);
  }

  // required .xtreemfs.pbrpc.reservationType type = 2;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->type(), target);
  }

  // required double capacity = 3;
  if (has_capacity()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->capacity(), target);
  }

  // optional double streamingThroughput = 4;
  if (has_streamingthroughput()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(4, this->streamingthroughput(), target);
  }

  // optional double randomThroughput = 5;
  if (has_randomthroughput()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(5, this->randomthroughput(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int reservation::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .xtreemfs.pbrpc.volumeIdentifier volume = 1;
    if (has_volume()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->volume());
    }

    // required .xtreemfs.pbrpc.reservationType type = 2;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // required double capacity = 3;
    if (has_capacity()) {
      total_size += 1 + 8;
    }

    // optional double streamingThroughput = 4;
    if (has_streamingthroughput()) {
      total_size += 1 + 8;
    }

    // optional double randomThroughput = 5;
    if (has_randomthroughput()) {
      total_size += 1 + 8;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void reservation::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const reservation* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const reservation*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void reservation::MergeFrom(const reservation& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_volume()) {
      mutable_volume()->::xtreemfs::pbrpc::volumeIdentifier::MergeFrom(from.volume());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_capacity()) {
      set_capacity(from.capacity());
    }
    if (from.has_streamingthroughput()) {
      set_streamingthroughput(from.streamingthroughput());
    }
    if (from.has_randomthroughput()) {
      set_randomthroughput(from.randomthroughput());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void reservation::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void reservation::CopyFrom(const reservation& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool reservation::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  if (has_volume()) {
    if (!this->volume().IsInitialized()) return false;
  }
  return true;
}

void reservation::Swap(reservation* other) {
  if (other != this) {
    std::swap(volume_, other->volume_);
    std::swap(type_, other->type_);
    std::swap(capacity_, other->capacity_);
    std::swap(streamingthroughput_, other->streamingthroughput_);
    std::swap(randomthroughput_, other->randomthroughput_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata reservation::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = reservation_descriptor_;
  metadata.reflection = reservation_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int reservationSet::kReservationsFieldNumber;
#endif  // !_MSC_VER

reservationSet::reservationSet()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void reservationSet::InitAsDefaultInstance() {
}

reservationSet::reservationSet(const reservationSet& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void reservationSet::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

reservationSet::~reservationSet() {
  SharedDtor();
}

void reservationSet::SharedDtor() {
  if (this != default_instance_) {
  }
}

void reservationSet::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* reservationSet::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return reservationSet_descriptor_;
}

const reservationSet& reservationSet::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_xtreemfs_2fScheduler_2eproto();
  return *default_instance_;
}

reservationSet* reservationSet::default_instance_ = NULL;

reservationSet* reservationSet::New() const {
  return new reservationSet;
}

void reservationSet::Clear() {
  reservations_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool reservationSet::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .xtreemfs.pbrpc.reservation reservations = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_reservations:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_reservations()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_reservations;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void reservationSet::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .xtreemfs.pbrpc.reservation reservations = 1;
  for (int i = 0; i < this->reservations_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->reservations(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* reservationSet::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .xtreemfs.pbrpc.reservation reservations = 1;
  for (int i = 0; i < this->reservations_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->reservations(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int reservationSet::ByteSize() const {
  int total_size = 0;

  // repeated .xtreemfs.pbrpc.reservation reservations = 1;
  total_size += 1 * this->reservations_size();
  for (int i = 0; i < this->reservations_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->reservations(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void reservationSet::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const reservationSet* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const reservationSet*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void reservationSet::MergeFrom(const reservationSet& from) {
  GOOGLE_CHECK_NE(&from, this);
  reservations_.MergeFrom(from.reservations_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void reservationSet::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void reservationSet::CopyFrom(const reservationSet& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool reservationSet::IsInitialized() const {

  for (int i = 0; i < reservations_size(); i++) {
    if (!this->reservations(i).IsInitialized()) return false;
  }
  return true;
}

void reservationSet::Swap(reservationSet* other) {
  if (other != this) {
    reservations_.Swap(&other->reservations_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata reservationSet::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = reservationSet_descriptor_;
  metadata.reflection = reservationSet_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int osdSet::kOsdFieldNumber;
#endif  // !_MSC_VER

osdSet::osdSet()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void osdSet::InitAsDefaultInstance() {
}

osdSet::osdSet(const osdSet& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void osdSet::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

osdSet::~osdSet() {
  SharedDtor();
}

void osdSet::SharedDtor() {
  if (this != default_instance_) {
  }
}

void osdSet::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* osdSet::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return osdSet_descriptor_;
}

const osdSet& osdSet::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_xtreemfs_2fScheduler_2eproto();
  return *default_instance_;
}

osdSet* osdSet::default_instance_ = NULL;

osdSet* osdSet::New() const {
  return new osdSet;
}

void osdSet::Clear() {
  osd_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool osdSet::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .xtreemfs.pbrpc.osdIdentifier osd = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_osd:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_osd()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_osd;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void osdSet::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .xtreemfs.pbrpc.osdIdentifier osd = 1;
  for (int i = 0; i < this->osd_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->osd(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* osdSet::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .xtreemfs.pbrpc.osdIdentifier osd = 1;
  for (int i = 0; i < this->osd_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->osd(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int osdSet::ByteSize() const {
  int total_size = 0;

  // repeated .xtreemfs.pbrpc.osdIdentifier osd = 1;
  total_size += 1 * this->osd_size();
  for (int i = 0; i < this->osd_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->osd(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void osdSet::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const osdSet* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const osdSet*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void osdSet::MergeFrom(const osdSet& from) {
  GOOGLE_CHECK_NE(&from, this);
  osd_.MergeFrom(from.osd_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void osdSet::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void osdSet::CopyFrom(const osdSet& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool osdSet::IsInitialized() const {

  for (int i = 0; i < osd_size(); i++) {
    if (!this->osd(i).IsInitialized()) return false;
  }
  return true;
}

void osdSet::Swap(osdSet* other) {
  if (other != this) {
    osd_.Swap(&other->osd_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata osdSet::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = osdSet_descriptor_;
  metadata.reflection = osdSet_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int freeResourcesResponse::kStreamingCapacityFieldNumber;
const int freeResourcesResponse::kStreamingThroughputFieldNumber;
const int freeResourcesResponse::kRandomCapacityFieldNumber;
const int freeResourcesResponse::kRandomThroughputFieldNumber;
#endif  // !_MSC_VER

freeResourcesResponse::freeResourcesResponse()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void freeResourcesResponse::InitAsDefaultInstance() {
}

freeResourcesResponse::freeResourcesResponse(const freeResourcesResponse& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void freeResourcesResponse::SharedCtor() {
  _cached_size_ = 0;
  streamingcapacity_ = 0;
  streamingthroughput_ = 0;
  randomcapacity_ = 0;
  randomthroughput_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

freeResourcesResponse::~freeResourcesResponse() {
  SharedDtor();
}

void freeResourcesResponse::SharedDtor() {
  if (this != default_instance_) {
  }
}

void freeResourcesResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* freeResourcesResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return freeResourcesResponse_descriptor_;
}

const freeResourcesResponse& freeResourcesResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_xtreemfs_2fScheduler_2eproto();
  return *default_instance_;
}

freeResourcesResponse* freeResourcesResponse::default_instance_ = NULL;

freeResourcesResponse* freeResourcesResponse::New() const {
  return new freeResourcesResponse;
}

void freeResourcesResponse::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    streamingcapacity_ = 0;
    streamingthroughput_ = 0;
    randomcapacity_ = 0;
    randomthroughput_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool freeResourcesResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required double streamingCapacity = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &streamingcapacity_)));
          set_has_streamingcapacity();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(17)) goto parse_streamingThroughput;
        break;
      }

      // required double streamingThroughput = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_streamingThroughput:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &streamingthroughput_)));
          set_has_streamingthroughput();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(25)) goto parse_randomCapacity;
        break;
      }

      // required double randomCapacity = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_randomCapacity:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &randomcapacity_)));
          set_has_randomcapacity();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(33)) goto parse_randomThroughput;
        break;
      }

      // required double randomThroughput = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_randomThroughput:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &randomthroughput_)));
          set_has_randomthroughput();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void freeResourcesResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required double streamingCapacity = 1;
  if (has_streamingcapacity()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->streamingcapacity(), output);
  }

  // required double streamingThroughput = 2;
  if (has_streamingthroughput()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->streamingthroughput(), output);
  }

  // required double randomCapacity = 3;
  if (has_randomcapacity()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->randomcapacity(), output);
  }

  // required double randomThroughput = 4;
  if (has_randomthroughput()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->randomthroughput(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* freeResourcesResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required double streamingCapacity = 1;
  if (has_streamingcapacity()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->streamingcapacity(), target);
  }

  // required double streamingThroughput = 2;
  if (has_streamingthroughput()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->streamingthroughput(), target);
  }

  // required double randomCapacity = 3;
  if (has_randomcapacity()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->randomcapacity(), target);
  }

  // required double randomThroughput = 4;
  if (has_randomthroughput()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(4, this->randomthroughput(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int freeResourcesResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required double streamingCapacity = 1;
    if (has_streamingcapacity()) {
      total_size += 1 + 8;
    }

    // required double streamingThroughput = 2;
    if (has_streamingthroughput()) {
      total_size += 1 + 8;
    }

    // required double randomCapacity = 3;
    if (has_randomcapacity()) {
      total_size += 1 + 8;
    }

    // required double randomThroughput = 4;
    if (has_randomthroughput()) {
      total_size += 1 + 8;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void freeResourcesResponse::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const freeResourcesResponse* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const freeResourcesResponse*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void freeResourcesResponse::MergeFrom(const freeResourcesResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_streamingcapacity()) {
      set_streamingcapacity(from.streamingcapacity());
    }
    if (from.has_streamingthroughput()) {
      set_streamingthroughput(from.streamingthroughput());
    }
    if (from.has_randomcapacity()) {
      set_randomcapacity(from.randomcapacity());
    }
    if (from.has_randomthroughput()) {
      set_randomthroughput(from.randomthroughput());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void freeResourcesResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void freeResourcesResponse::CopyFrom(const freeResourcesResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool freeResourcesResponse::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void freeResourcesResponse::Swap(freeResourcesResponse* other) {
  if (other != this) {
    std::swap(streamingcapacity_, other->streamingcapacity_);
    std::swap(streamingthroughput_, other->streamingthroughput_);
    std::swap(randomcapacity_, other->randomcapacity_);
    std::swap(randomthroughput_, other->randomthroughput_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata freeResourcesResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = freeResourcesResponse_descriptor_;
  metadata.reflection = freeResourcesResponse_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pbrpc
}  // namespace xtreemfs

// @@protoc_insertion_point(global_scope)
