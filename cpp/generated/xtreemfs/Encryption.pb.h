// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: xtreemfs/Encryption.proto

#ifndef PROTOBUF_xtreemfs_2fEncryption_2eproto__INCLUDED
#define PROTOBUF_xtreemfs_2fEncryption_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace xtreemfs {
namespace pbrpc {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_xtreemfs_2fEncryption_2eproto();
void protobuf_AssignDesc_xtreemfs_2fEncryption_2eproto();
void protobuf_ShutdownFile_xtreemfs_2fEncryption_2eproto();

class SymEncBytes;
class FileLockbox;
class SignedFileLockbox;

// ===================================================================

class SymEncBytes : public ::google::protobuf::Message {
 public:
  SymEncBytes();
  virtual ~SymEncBytes();

  SymEncBytes(const SymEncBytes& from);

  inline SymEncBytes& operator=(const SymEncBytes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SymEncBytes& default_instance();

  void Swap(SymEncBytes* other);

  // implements Message ----------------------------------------------

  SymEncBytes* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SymEncBytes& from);
  void MergeFrom(const SymEncBytes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string cipher = 1;
  inline bool has_cipher() const;
  inline void clear_cipher();
  static const int kCipherFieldNumber = 1;
  inline const ::std::string& cipher() const;
  inline void set_cipher(const ::std::string& value);
  inline void set_cipher(const char* value);
  inline void set_cipher(const char* value, size_t size);
  inline ::std::string* mutable_cipher();
  inline ::std::string* release_cipher();
  inline void set_allocated_cipher(::std::string* cipher);

  // required bytes iv = 2;
  inline bool has_iv() const;
  inline void clear_iv();
  static const int kIvFieldNumber = 2;
  inline const ::std::string& iv() const;
  inline void set_iv(const ::std::string& value);
  inline void set_iv(const char* value);
  inline void set_iv(const void* value, size_t size);
  inline ::std::string* mutable_iv();
  inline ::std::string* release_iv();
  inline void set_allocated_iv(::std::string* iv);

  // required bytes ciphertext = 3;
  inline bool has_ciphertext() const;
  inline void clear_ciphertext();
  static const int kCiphertextFieldNumber = 3;
  inline const ::std::string& ciphertext() const;
  inline void set_ciphertext(const ::std::string& value);
  inline void set_ciphertext(const char* value);
  inline void set_ciphertext(const void* value, size_t size);
  inline ::std::string* mutable_ciphertext();
  inline ::std::string* release_ciphertext();
  inline void set_allocated_ciphertext(::std::string* ciphertext);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.SymEncBytes)
 private:
  inline void set_has_cipher();
  inline void clear_has_cipher();
  inline void set_has_iv();
  inline void clear_has_iv();
  inline void set_has_ciphertext();
  inline void clear_has_ciphertext();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* cipher_;
  ::std::string* iv_;
  ::std::string* ciphertext_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fEncryption_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fEncryption_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fEncryption_2eproto();

  void InitAsDefaultInstance();
  static SymEncBytes* default_instance_;
};
// -------------------------------------------------------------------

class FileLockbox : public ::google::protobuf::Message {
 public:
  FileLockbox();
  virtual ~FileLockbox();

  FileLockbox(const FileLockbox& from);

  inline FileLockbox& operator=(const FileLockbox& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FileLockbox& default_instance();

  void Swap(FileLockbox* other);

  // implements Message ----------------------------------------------

  FileLockbox* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FileLockbox& from);
  void MergeFrom(const FileLockbox& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string file_id = 1;
  inline bool has_file_id() const;
  inline void clear_file_id();
  static const int kFileIdFieldNumber = 1;
  inline const ::std::string& file_id() const;
  inline void set_file_id(const ::std::string& value);
  inline void set_file_id(const char* value);
  inline void set_file_id(const char* value, size_t size);
  inline ::std::string* mutable_file_id();
  inline ::std::string* release_file_id();
  inline void set_allocated_file_id(::std::string* file_id);

  // required string file_id_salt = 2;
  inline bool has_file_id_salt() const;
  inline void clear_file_id_salt();
  static const int kFileIdSaltFieldNumber = 2;
  inline const ::std::string& file_id_salt() const;
  inline void set_file_id_salt(const ::std::string& value);
  inline void set_file_id_salt(const char* value);
  inline void set_file_id_salt(const char* value, size_t size);
  inline ::std::string* mutable_file_id_salt();
  inline ::std::string* release_file_id_salt();
  inline void set_allocated_file_id_salt(::std::string* file_id_salt);

  // required string cipher = 3;
  inline bool has_cipher() const;
  inline void clear_cipher();
  static const int kCipherFieldNumber = 3;
  inline const ::std::string& cipher() const;
  inline void set_cipher(const ::std::string& value);
  inline void set_cipher(const char* value);
  inline void set_cipher(const char* value, size_t size);
  inline ::std::string* mutable_cipher();
  inline ::std::string* release_cipher();
  inline void set_allocated_cipher(::std::string* cipher);

  // required bytes enc_key = 4;
  inline bool has_enc_key() const;
  inline void clear_enc_key();
  static const int kEncKeyFieldNumber = 4;
  inline const ::std::string& enc_key() const;
  inline void set_enc_key(const ::std::string& value);
  inline void set_enc_key(const char* value);
  inline void set_enc_key(const void* value, size_t size);
  inline ::std::string* mutable_enc_key();
  inline ::std::string* release_enc_key();
  inline void set_allocated_enc_key(::std::string* enc_key);

  // required bytes sign_key = 5;
  inline bool has_sign_key() const;
  inline void clear_sign_key();
  static const int kSignKeyFieldNumber = 5;
  inline const ::std::string& sign_key() const;
  inline void set_sign_key(const ::std::string& value);
  inline void set_sign_key(const char* value);
  inline void set_sign_key(const void* value, size_t size);
  inline ::std::string* mutable_sign_key();
  inline ::std::string* release_sign_key();
  inline void set_allocated_sign_key(::std::string* sign_key);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.FileLockbox)
 private:
  inline void set_has_file_id();
  inline void clear_has_file_id();
  inline void set_has_file_id_salt();
  inline void clear_has_file_id_salt();
  inline void set_has_cipher();
  inline void clear_has_cipher();
  inline void set_has_enc_key();
  inline void clear_has_enc_key();
  inline void set_has_sign_key();
  inline void clear_has_sign_key();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* file_id_;
  ::std::string* file_id_salt_;
  ::std::string* cipher_;
  ::std::string* enc_key_;
  ::std::string* sign_key_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fEncryption_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fEncryption_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fEncryption_2eproto();

  void InitAsDefaultInstance();
  static FileLockbox* default_instance_;
};
// -------------------------------------------------------------------

class SignedFileLockbox : public ::google::protobuf::Message {
 public:
  SignedFileLockbox();
  virtual ~SignedFileLockbox();

  SignedFileLockbox(const SignedFileLockbox& from);

  inline SignedFileLockbox& operator=(const SignedFileLockbox& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SignedFileLockbox& default_instance();

  void Swap(SignedFileLockbox* other);

  // implements Message ----------------------------------------------

  SignedFileLockbox* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SignedFileLockbox& from);
  void MergeFrom(const SignedFileLockbox& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes lockbox = 1;
  inline bool has_lockbox() const;
  inline void clear_lockbox();
  static const int kLockboxFieldNumber = 1;
  inline const ::std::string& lockbox() const;
  inline void set_lockbox(const ::std::string& value);
  inline void set_lockbox(const char* value);
  inline void set_lockbox(const void* value, size_t size);
  inline ::std::string* mutable_lockbox();
  inline ::std::string* release_lockbox();
  inline void set_allocated_lockbox(::std::string* lockbox);

  // required bytes signature = 2;
  inline bool has_signature() const;
  inline void clear_signature();
  static const int kSignatureFieldNumber = 2;
  inline const ::std::string& signature() const;
  inline void set_signature(const ::std::string& value);
  inline void set_signature(const char* value);
  inline void set_signature(const void* value, size_t size);
  inline ::std::string* mutable_signature();
  inline ::std::string* release_signature();
  inline void set_allocated_signature(::std::string* signature);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.SignedFileLockbox)
 private:
  inline void set_has_lockbox();
  inline void clear_has_lockbox();
  inline void set_has_signature();
  inline void clear_has_signature();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* lockbox_;
  ::std::string* signature_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fEncryption_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fEncryption_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fEncryption_2eproto();

  void InitAsDefaultInstance();
  static SignedFileLockbox* default_instance_;
};
// ===================================================================


// ===================================================================

// SymEncBytes

// required string cipher = 1;
inline bool SymEncBytes::has_cipher() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SymEncBytes::set_has_cipher() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SymEncBytes::clear_has_cipher() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SymEncBytes::clear_cipher() {
  if (cipher_ != &::google::protobuf::internal::kEmptyString) {
    cipher_->clear();
  }
  clear_has_cipher();
}
inline const ::std::string& SymEncBytes::cipher() const {
  return *cipher_;
}
inline void SymEncBytes::set_cipher(const ::std::string& value) {
  set_has_cipher();
  if (cipher_ == &::google::protobuf::internal::kEmptyString) {
    cipher_ = new ::std::string;
  }
  cipher_->assign(value);
}
inline void SymEncBytes::set_cipher(const char* value) {
  set_has_cipher();
  if (cipher_ == &::google::protobuf::internal::kEmptyString) {
    cipher_ = new ::std::string;
  }
  cipher_->assign(value);
}
inline void SymEncBytes::set_cipher(const char* value, size_t size) {
  set_has_cipher();
  if (cipher_ == &::google::protobuf::internal::kEmptyString) {
    cipher_ = new ::std::string;
  }
  cipher_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SymEncBytes::mutable_cipher() {
  set_has_cipher();
  if (cipher_ == &::google::protobuf::internal::kEmptyString) {
    cipher_ = new ::std::string;
  }
  return cipher_;
}
inline ::std::string* SymEncBytes::release_cipher() {
  clear_has_cipher();
  if (cipher_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cipher_;
    cipher_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SymEncBytes::set_allocated_cipher(::std::string* cipher) {
  if (cipher_ != &::google::protobuf::internal::kEmptyString) {
    delete cipher_;
  }
  if (cipher) {
    set_has_cipher();
    cipher_ = cipher;
  } else {
    clear_has_cipher();
    cipher_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes iv = 2;
inline bool SymEncBytes::has_iv() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SymEncBytes::set_has_iv() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SymEncBytes::clear_has_iv() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SymEncBytes::clear_iv() {
  if (iv_ != &::google::protobuf::internal::kEmptyString) {
    iv_->clear();
  }
  clear_has_iv();
}
inline const ::std::string& SymEncBytes::iv() const {
  return *iv_;
}
inline void SymEncBytes::set_iv(const ::std::string& value) {
  set_has_iv();
  if (iv_ == &::google::protobuf::internal::kEmptyString) {
    iv_ = new ::std::string;
  }
  iv_->assign(value);
}
inline void SymEncBytes::set_iv(const char* value) {
  set_has_iv();
  if (iv_ == &::google::protobuf::internal::kEmptyString) {
    iv_ = new ::std::string;
  }
  iv_->assign(value);
}
inline void SymEncBytes::set_iv(const void* value, size_t size) {
  set_has_iv();
  if (iv_ == &::google::protobuf::internal::kEmptyString) {
    iv_ = new ::std::string;
  }
  iv_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SymEncBytes::mutable_iv() {
  set_has_iv();
  if (iv_ == &::google::protobuf::internal::kEmptyString) {
    iv_ = new ::std::string;
  }
  return iv_;
}
inline ::std::string* SymEncBytes::release_iv() {
  clear_has_iv();
  if (iv_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = iv_;
    iv_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SymEncBytes::set_allocated_iv(::std::string* iv) {
  if (iv_ != &::google::protobuf::internal::kEmptyString) {
    delete iv_;
  }
  if (iv) {
    set_has_iv();
    iv_ = iv;
  } else {
    clear_has_iv();
    iv_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes ciphertext = 3;
inline bool SymEncBytes::has_ciphertext() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SymEncBytes::set_has_ciphertext() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SymEncBytes::clear_has_ciphertext() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SymEncBytes::clear_ciphertext() {
  if (ciphertext_ != &::google::protobuf::internal::kEmptyString) {
    ciphertext_->clear();
  }
  clear_has_ciphertext();
}
inline const ::std::string& SymEncBytes::ciphertext() const {
  return *ciphertext_;
}
inline void SymEncBytes::set_ciphertext(const ::std::string& value) {
  set_has_ciphertext();
  if (ciphertext_ == &::google::protobuf::internal::kEmptyString) {
    ciphertext_ = new ::std::string;
  }
  ciphertext_->assign(value);
}
inline void SymEncBytes::set_ciphertext(const char* value) {
  set_has_ciphertext();
  if (ciphertext_ == &::google::protobuf::internal::kEmptyString) {
    ciphertext_ = new ::std::string;
  }
  ciphertext_->assign(value);
}
inline void SymEncBytes::set_ciphertext(const void* value, size_t size) {
  set_has_ciphertext();
  if (ciphertext_ == &::google::protobuf::internal::kEmptyString) {
    ciphertext_ = new ::std::string;
  }
  ciphertext_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SymEncBytes::mutable_ciphertext() {
  set_has_ciphertext();
  if (ciphertext_ == &::google::protobuf::internal::kEmptyString) {
    ciphertext_ = new ::std::string;
  }
  return ciphertext_;
}
inline ::std::string* SymEncBytes::release_ciphertext() {
  clear_has_ciphertext();
  if (ciphertext_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ciphertext_;
    ciphertext_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SymEncBytes::set_allocated_ciphertext(::std::string* ciphertext) {
  if (ciphertext_ != &::google::protobuf::internal::kEmptyString) {
    delete ciphertext_;
  }
  if (ciphertext) {
    set_has_ciphertext();
    ciphertext_ = ciphertext;
  } else {
    clear_has_ciphertext();
    ciphertext_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// FileLockbox

// required string file_id = 1;
inline bool FileLockbox::has_file_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FileLockbox::set_has_file_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FileLockbox::clear_has_file_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FileLockbox::clear_file_id() {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    file_id_->clear();
  }
  clear_has_file_id();
}
inline const ::std::string& FileLockbox::file_id() const {
  return *file_id_;
}
inline void FileLockbox::set_file_id(const ::std::string& value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void FileLockbox::set_file_id(const char* value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void FileLockbox::set_file_id(const char* value, size_t size) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FileLockbox::mutable_file_id() {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  return file_id_;
}
inline ::std::string* FileLockbox::release_file_id() {
  clear_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_id_;
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FileLockbox::set_allocated_file_id(::std::string* file_id) {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    delete file_id_;
  }
  if (file_id) {
    set_has_file_id();
    file_id_ = file_id;
  } else {
    clear_has_file_id();
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string file_id_salt = 2;
inline bool FileLockbox::has_file_id_salt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FileLockbox::set_has_file_id_salt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FileLockbox::clear_has_file_id_salt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FileLockbox::clear_file_id_salt() {
  if (file_id_salt_ != &::google::protobuf::internal::kEmptyString) {
    file_id_salt_->clear();
  }
  clear_has_file_id_salt();
}
inline const ::std::string& FileLockbox::file_id_salt() const {
  return *file_id_salt_;
}
inline void FileLockbox::set_file_id_salt(const ::std::string& value) {
  set_has_file_id_salt();
  if (file_id_salt_ == &::google::protobuf::internal::kEmptyString) {
    file_id_salt_ = new ::std::string;
  }
  file_id_salt_->assign(value);
}
inline void FileLockbox::set_file_id_salt(const char* value) {
  set_has_file_id_salt();
  if (file_id_salt_ == &::google::protobuf::internal::kEmptyString) {
    file_id_salt_ = new ::std::string;
  }
  file_id_salt_->assign(value);
}
inline void FileLockbox::set_file_id_salt(const char* value, size_t size) {
  set_has_file_id_salt();
  if (file_id_salt_ == &::google::protobuf::internal::kEmptyString) {
    file_id_salt_ = new ::std::string;
  }
  file_id_salt_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FileLockbox::mutable_file_id_salt() {
  set_has_file_id_salt();
  if (file_id_salt_ == &::google::protobuf::internal::kEmptyString) {
    file_id_salt_ = new ::std::string;
  }
  return file_id_salt_;
}
inline ::std::string* FileLockbox::release_file_id_salt() {
  clear_has_file_id_salt();
  if (file_id_salt_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_id_salt_;
    file_id_salt_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FileLockbox::set_allocated_file_id_salt(::std::string* file_id_salt) {
  if (file_id_salt_ != &::google::protobuf::internal::kEmptyString) {
    delete file_id_salt_;
  }
  if (file_id_salt) {
    set_has_file_id_salt();
    file_id_salt_ = file_id_salt;
  } else {
    clear_has_file_id_salt();
    file_id_salt_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string cipher = 3;
inline bool FileLockbox::has_cipher() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FileLockbox::set_has_cipher() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FileLockbox::clear_has_cipher() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FileLockbox::clear_cipher() {
  if (cipher_ != &::google::protobuf::internal::kEmptyString) {
    cipher_->clear();
  }
  clear_has_cipher();
}
inline const ::std::string& FileLockbox::cipher() const {
  return *cipher_;
}
inline void FileLockbox::set_cipher(const ::std::string& value) {
  set_has_cipher();
  if (cipher_ == &::google::protobuf::internal::kEmptyString) {
    cipher_ = new ::std::string;
  }
  cipher_->assign(value);
}
inline void FileLockbox::set_cipher(const char* value) {
  set_has_cipher();
  if (cipher_ == &::google::protobuf::internal::kEmptyString) {
    cipher_ = new ::std::string;
  }
  cipher_->assign(value);
}
inline void FileLockbox::set_cipher(const char* value, size_t size) {
  set_has_cipher();
  if (cipher_ == &::google::protobuf::internal::kEmptyString) {
    cipher_ = new ::std::string;
  }
  cipher_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FileLockbox::mutable_cipher() {
  set_has_cipher();
  if (cipher_ == &::google::protobuf::internal::kEmptyString) {
    cipher_ = new ::std::string;
  }
  return cipher_;
}
inline ::std::string* FileLockbox::release_cipher() {
  clear_has_cipher();
  if (cipher_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cipher_;
    cipher_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FileLockbox::set_allocated_cipher(::std::string* cipher) {
  if (cipher_ != &::google::protobuf::internal::kEmptyString) {
    delete cipher_;
  }
  if (cipher) {
    set_has_cipher();
    cipher_ = cipher;
  } else {
    clear_has_cipher();
    cipher_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes enc_key = 4;
inline bool FileLockbox::has_enc_key() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FileLockbox::set_has_enc_key() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FileLockbox::clear_has_enc_key() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FileLockbox::clear_enc_key() {
  if (enc_key_ != &::google::protobuf::internal::kEmptyString) {
    enc_key_->clear();
  }
  clear_has_enc_key();
}
inline const ::std::string& FileLockbox::enc_key() const {
  return *enc_key_;
}
inline void FileLockbox::set_enc_key(const ::std::string& value) {
  set_has_enc_key();
  if (enc_key_ == &::google::protobuf::internal::kEmptyString) {
    enc_key_ = new ::std::string;
  }
  enc_key_->assign(value);
}
inline void FileLockbox::set_enc_key(const char* value) {
  set_has_enc_key();
  if (enc_key_ == &::google::protobuf::internal::kEmptyString) {
    enc_key_ = new ::std::string;
  }
  enc_key_->assign(value);
}
inline void FileLockbox::set_enc_key(const void* value, size_t size) {
  set_has_enc_key();
  if (enc_key_ == &::google::protobuf::internal::kEmptyString) {
    enc_key_ = new ::std::string;
  }
  enc_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FileLockbox::mutable_enc_key() {
  set_has_enc_key();
  if (enc_key_ == &::google::protobuf::internal::kEmptyString) {
    enc_key_ = new ::std::string;
  }
  return enc_key_;
}
inline ::std::string* FileLockbox::release_enc_key() {
  clear_has_enc_key();
  if (enc_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = enc_key_;
    enc_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FileLockbox::set_allocated_enc_key(::std::string* enc_key) {
  if (enc_key_ != &::google::protobuf::internal::kEmptyString) {
    delete enc_key_;
  }
  if (enc_key) {
    set_has_enc_key();
    enc_key_ = enc_key;
  } else {
    clear_has_enc_key();
    enc_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes sign_key = 5;
inline bool FileLockbox::has_sign_key() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FileLockbox::set_has_sign_key() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FileLockbox::clear_has_sign_key() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FileLockbox::clear_sign_key() {
  if (sign_key_ != &::google::protobuf::internal::kEmptyString) {
    sign_key_->clear();
  }
  clear_has_sign_key();
}
inline const ::std::string& FileLockbox::sign_key() const {
  return *sign_key_;
}
inline void FileLockbox::set_sign_key(const ::std::string& value) {
  set_has_sign_key();
  if (sign_key_ == &::google::protobuf::internal::kEmptyString) {
    sign_key_ = new ::std::string;
  }
  sign_key_->assign(value);
}
inline void FileLockbox::set_sign_key(const char* value) {
  set_has_sign_key();
  if (sign_key_ == &::google::protobuf::internal::kEmptyString) {
    sign_key_ = new ::std::string;
  }
  sign_key_->assign(value);
}
inline void FileLockbox::set_sign_key(const void* value, size_t size) {
  set_has_sign_key();
  if (sign_key_ == &::google::protobuf::internal::kEmptyString) {
    sign_key_ = new ::std::string;
  }
  sign_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FileLockbox::mutable_sign_key() {
  set_has_sign_key();
  if (sign_key_ == &::google::protobuf::internal::kEmptyString) {
    sign_key_ = new ::std::string;
  }
  return sign_key_;
}
inline ::std::string* FileLockbox::release_sign_key() {
  clear_has_sign_key();
  if (sign_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sign_key_;
    sign_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FileLockbox::set_allocated_sign_key(::std::string* sign_key) {
  if (sign_key_ != &::google::protobuf::internal::kEmptyString) {
    delete sign_key_;
  }
  if (sign_key) {
    set_has_sign_key();
    sign_key_ = sign_key;
  } else {
    clear_has_sign_key();
    sign_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SignedFileLockbox

// required bytes lockbox = 1;
inline bool SignedFileLockbox::has_lockbox() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SignedFileLockbox::set_has_lockbox() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SignedFileLockbox::clear_has_lockbox() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SignedFileLockbox::clear_lockbox() {
  if (lockbox_ != &::google::protobuf::internal::kEmptyString) {
    lockbox_->clear();
  }
  clear_has_lockbox();
}
inline const ::std::string& SignedFileLockbox::lockbox() const {
  return *lockbox_;
}
inline void SignedFileLockbox::set_lockbox(const ::std::string& value) {
  set_has_lockbox();
  if (lockbox_ == &::google::protobuf::internal::kEmptyString) {
    lockbox_ = new ::std::string;
  }
  lockbox_->assign(value);
}
inline void SignedFileLockbox::set_lockbox(const char* value) {
  set_has_lockbox();
  if (lockbox_ == &::google::protobuf::internal::kEmptyString) {
    lockbox_ = new ::std::string;
  }
  lockbox_->assign(value);
}
inline void SignedFileLockbox::set_lockbox(const void* value, size_t size) {
  set_has_lockbox();
  if (lockbox_ == &::google::protobuf::internal::kEmptyString) {
    lockbox_ = new ::std::string;
  }
  lockbox_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignedFileLockbox::mutable_lockbox() {
  set_has_lockbox();
  if (lockbox_ == &::google::protobuf::internal::kEmptyString) {
    lockbox_ = new ::std::string;
  }
  return lockbox_;
}
inline ::std::string* SignedFileLockbox::release_lockbox() {
  clear_has_lockbox();
  if (lockbox_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = lockbox_;
    lockbox_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SignedFileLockbox::set_allocated_lockbox(::std::string* lockbox) {
  if (lockbox_ != &::google::protobuf::internal::kEmptyString) {
    delete lockbox_;
  }
  if (lockbox) {
    set_has_lockbox();
    lockbox_ = lockbox;
  } else {
    clear_has_lockbox();
    lockbox_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes signature = 2;
inline bool SignedFileLockbox::has_signature() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SignedFileLockbox::set_has_signature() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SignedFileLockbox::clear_has_signature() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SignedFileLockbox::clear_signature() {
  if (signature_ != &::google::protobuf::internal::kEmptyString) {
    signature_->clear();
  }
  clear_has_signature();
}
inline const ::std::string& SignedFileLockbox::signature() const {
  return *signature_;
}
inline void SignedFileLockbox::set_signature(const ::std::string& value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void SignedFileLockbox::set_signature(const char* value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void SignedFileLockbox::set_signature(const void* value, size_t size) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignedFileLockbox::mutable_signature() {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  return signature_;
}
inline ::std::string* SignedFileLockbox::release_signature() {
  clear_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = signature_;
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SignedFileLockbox::set_allocated_signature(::std::string* signature) {
  if (signature_ != &::google::protobuf::internal::kEmptyString) {
    delete signature_;
  }
  if (signature) {
    set_has_signature();
    signature_ = signature;
  } else {
    clear_has_signature();
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pbrpc
}  // namespace xtreemfs

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_xtreemfs_2fEncryption_2eproto__INCLUDED
